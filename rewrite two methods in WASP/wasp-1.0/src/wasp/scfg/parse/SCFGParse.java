/*
 * Copyright 2006 Yuk Wah Wong (The University of Texas at Austin).
 * 
 * This file is part of the WASP distribution.
 *
 * WASP is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * WASP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with WASP; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
 */
package wasp.scfg.parse;

import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import wasp.data.Node;
import wasp.data.Symbol;
import wasp.main.Config;
import wasp.main.Parse;
import wasp.scfg.RuleSymbol;
import wasp.util.Arrays;
import wasp.util.Int;
import wasp.util.Pair;
import wasp.util.Short;

/**
 * Parse trees generated by an SCFG parser.
 * 
 * @author ywwong
 *
 */
public class SCFGParse extends Parse {

	private static Logger logger = Logger.getLogger(SCFGParse.class.getName());
	static {
		logger.setLevel(Level.FINEST);
	}
	
	public Item item;
	
	public SCFGParse(Item item, double score) {
		super(score);
		this.item = item;
	}
	
	public SCFGParse(String str, double score) {
		super(str, score);
	}
	
	public Node toTree() {
		return (item==null) ? null : toTree(item);
	}
	
	private Node toTree(Item item) {
		Node n = new Node(new RuleSymbol(item.rule));
		while (item != null) {
			if (item.getBackComplete(0) != null)
				n.addChildToFront(toTree(item.getBackComplete(0)));
			item = item.getBack(0);
		}
		return n;
	}

	/**
	 * Returns the meaning representation given by this parse.
	 */
	public String toStr() {
		if (str != null)
			return str;
		if (item == null)
			return null;
		HashMap items = new HashMap();
		addItems(item, items);
		Symbol[] syms = toSyms(item, items);
		return (syms==null) ? null : Config.getMRLGrammar().combine(syms);
	}
	
	private void addItems(Item item, HashMap items) {
		items.put(key(item.start, item.rule.getLhs()), item);
		while (item != null) {
			if (item.getBackComplete(0) != null)
				addItems(item.getBackComplete(0), items);
			item = item.getBack(0);
		}
	}
	
	private Pair key(short start, int lhs) {
		return new Pair(new Short(start), new Int(lhs));
	}
	
	private Symbol[] toSyms(Item item, HashMap items) {
		if (item.rule.getProduction().isAnaphor()) {
			Item a;
			Symbol sym = item.rule.getF((short) 0);
			for (short i = (short) (item.start-1); i >= 0; --i)
				if ((a = (Item) items.get(key(i, sym.getId()))) != null)
					return toSyms(a, items);
			return null;
		}
		Symbol[] syms = (Symbol[]) Arrays.copy(item.rule.getF());
		while (item != null) {
			if (item.getBackComplete(0) != null) {
				short index = item.rule.getE(item.getBack(0).dot).getIndex();
				syms = apply(syms, index, toSyms(item.getBackComplete(0), items));
			}
			item = item.getBack(0);
		}
		return syms;
	}
	
	private Symbol[] apply(Symbol[] syms, short index, Symbol[] replacement) {
		if (syms == null || replacement == null)
			return null;
		for (short i = 0; i < syms.length; ++i)
			if (syms[i].getIndex() == index)
				return (Symbol[]) Arrays.replace(syms, i, replacement);
		return syms;
	}
	
}
